"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/ReactNativeFile.js
var require_ReactNativeFile = __commonJS({
  "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/ReactNativeFile.js"(exports, module2) {
    "use strict";
    module2.exports = function ReactNativeFile(_ref) {
      var uri = _ref.uri, name = _ref.name, type = _ref.type;
      this.uri = uri;
      this.name = name;
      this.type = type;
    };
  }
});

// ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/isExtractableFile.js
var require_isExtractableFile = __commonJS({
  "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/isExtractableFile.js"(exports, module2) {
    "use strict";
    var ReactNativeFile = require_ReactNativeFile();
    module2.exports = function isExtractableFile(value) {
      return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile;
    };
  }
});

// ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/extractFiles.js
var require_extractFiles = __commonJS({
  "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/extractFiles.js"(exports, module2) {
    "use strict";
    var defaultIsExtractableFile = require_isExtractableFile();
    module2.exports = function extractFiles(value, path, isExtractableFile) {
      if (path === void 0) {
        path = "";
      }
      if (isExtractableFile === void 0) {
        isExtractableFile = defaultIsExtractableFile;
      }
      var clone;
      var files = /* @__PURE__ */ new Map();
      function addFile(paths, file) {
        var storedPaths = files.get(file);
        if (storedPaths)
          storedPaths.push.apply(storedPaths, paths);
        else
          files.set(file, paths);
      }
      if (isExtractableFile(value)) {
        clone = null;
        addFile([path], value);
      } else {
        var prefix = path ? path + "." : "";
        if (typeof FileList !== "undefined" && value instanceof FileList)
          clone = Array.prototype.map.call(value, function(file, i2) {
            addFile(["" + prefix + i2], file);
            return null;
          });
        else if (Array.isArray(value))
          clone = value.map(function(child, i2) {
            var result2 = extractFiles(child, "" + prefix + i2, isExtractableFile);
            result2.files.forEach(addFile);
            return result2.clone;
          });
        else if (value && value.constructor === Object) {
          clone = {};
          for (var i in value) {
            var result = extractFiles(value[i], "" + prefix + i, isExtractableFile);
            result.files.forEach(addFile);
            clone[i] = result.clone;
          }
        } else
          clone = value;
      }
      return {
        clone,
        files
      };
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AwesomeGraphQLClient: () => AwesomeGraphQLClient,
  GraphQLRequestError: () => GraphQLRequestError,
  gql: () => gql,
  isFileUpload: () => isFileUpload
});
module.exports = __toCommonJS(src_exports);

// ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/index.mjs
var import_extractFiles = __toESM(require_extractFiles(), 1);

// src/GraphQLRequestError.ts
var GraphQLRequestError = class extends Error {
  query;
  variables;
  response;
  extensions;
  constructor({
    query,
    variables,
    response,
    message,
    extensions
  }) {
    super(`GraphQL Request Error: ${message}`);
    this.query = query;
    if (variables) {
      this.variables = variables;
    }
    if (extensions) {
      this.extensions = extensions;
    }
    Object.defineProperty(this, "response", {
      enumerable: false,
      value: response
    });
  }
};

// src/util/assert.ts
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}

// src/util/formatGetRequestUrl.ts
function formatGetRequestUrl({
  endpoint,
  query,
  variables
}) {
  const searchParams = new URLSearchParams();
  searchParams.set("query", query);
  if (variables && Object.keys(variables).length > 0) {
    searchParams.set("variables", JSON.stringify(variables));
  }
  return `${endpoint}?${searchParams.toString()}`;
}

// src/util/isFileUpload.ts
var isStreamLike = (value) => typeof value === "object" && value !== null && typeof value.pipe === "function";
var isPromiseLike = (value) => typeof value === "object" && value !== null && typeof value.then === "function";
var isFileUpload = (value) => typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || typeof Buffer !== "undefined" && value instanceof Buffer || isStreamLike(value) || isPromiseLike(value);

// src/util/isResponseJSON.ts
var isResponseJSON = (response) => (response.headers.get("Content-Type") ?? "").includes("application/json");

// src/util/normalizeHeaders.ts
var isHeaders = (headers) => typeof headers.get === "function";
var isIterableHeaders = (headers) => typeof headers[Symbol.iterator] === "function";
function normalizeHeaders(headers) {
  if (headers === void 0) {
    return {};
  }
  if (isHeaders(headers)) {
    const newHeaders = {};
    headers.forEach((value, key) => {
      newHeaders[key] = value;
    });
    return newHeaders;
  }
  if (isIterableHeaders(headers)) {
    const newHeaders = {};
    for (const [key, value] of headers) {
      newHeaders[key.toLowerCase()] = value;
    }
    return newHeaders;
  }
  return Object.fromEntries(
    Object.entries(headers).map(([key, value]) => [key.toLowerCase(), value])
  );
}

// src/AwesomeGraphQLClient.ts
var AwesomeGraphQLClient = class {
  endpoint;
  fetch;
  fetchOptions;
  formatQuery;
  FormData;
  onError;
  isFileUpload;
  constructor(config) {
    assert(config.endpoint !== void 0, "endpoint is required");
    assert(
      config.fetch !== void 0 || typeof fetch !== "undefined",
      "Fetch must be polyfilled or passed in new AwesomeGraphQLClient({ fetch })"
    );
    assert(
      !config.formatQuery || typeof config.formatQuery === "function",
      "Invalid config value: `formatQuery` must be a function"
    );
    assert(
      !config.onError || typeof config.onError === "function",
      "Invalid config value: `onError` must be a function"
    );
    assert(
      !config.isFileUpload || typeof config.isFileUpload === "function",
      "Invalid config value: `isFileUpload` should be a function"
    );
    this.endpoint = config.endpoint;
    this.fetch = config.fetch || fetch.bind(null);
    this.fetchOptions = config.fetchOptions;
    this.FormData = config.FormData !== void 0 ? config.FormData : typeof FormData !== "undefined" ? FormData : void 0;
    this.formatQuery = config.formatQuery;
    this.onError = config.onError;
    this.isFileUpload = config.isFileUpload || isFileUpload;
  }
  createRequestBody(query, variables) {
    const { clone, files } = (0, import_extractFiles.default)(
      { query, variables },
      "",
      this.isFileUpload
    );
    const operationJSON = JSON.stringify(clone);
    if (files.size === 0) {
      return operationJSON;
    }
    assert(
      this.FormData !== void 0,
      "FormData must be polyfilled or passed in new AwesomeGraphQLClient({ FormData })"
    );
    const form = new this.FormData();
    form.append("operations", operationJSON);
    const map = {};
    let i = 0;
    for (const paths of files.values()) {
      map[++i] = paths;
    }
    form.append("map", JSON.stringify(map));
    i = 0;
    for (const file of files.keys()) {
      form.append(`${++i}`, file);
    }
    return form;
  }
  /**
   * Sets a new GraphQL endpoint
   *
   * @param endpoint new overrides for endpoint
   */
  setEndpoint(endpoint) {
    assert(endpoint !== void 0, "endpoint is required");
    this.endpoint = endpoint;
  }
  /**
   * Returns current GraphQL endpoint
   */
  getEndpoint() {
    return this.endpoint;
  }
  /**
   * Sets new overrides for fetch options
   *
   * @param fetchOptions new overrides for fetch options
   */
  setFetchOptions(fetchOptions) {
    this.fetchOptions = fetchOptions;
  }
  /**
   * Returns current overrides for fetch options
   */
  getFetchOptions() {
    return this.fetchOptions;
  }
  /**
   * Sends GraphQL Request and returns object with 'ok: true', 'data' and 'response' fields
   * or with 'ok: false' and 'error' fields.
   * Notice: this function never throws
   *
   * @example
   * const result = await requestSafe(...)
   * if (!result.ok) {
   *   throw result.error
   * }
   * console.log(result.data)
   *
   * @param query query
   * @param variables variables
   * @param fetchOptions overrides for fetch options
   */
  async requestSafe(query, variables, fetchOptions) {
    try {
      const queryAsString = this.formatQuery ? this.formatQuery(query) : query;
      assert(
        typeof queryAsString === "string",
        `Query should be a string, not ${typeof queryAsString}. Otherwise provide formatQuery option`
      );
      const options = {
        method: "POST",
        ...this.fetchOptions,
        ...fetchOptions,
        headers: {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          ...normalizeHeaders(this.fetchOptions?.headers),
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          ...normalizeHeaders(fetchOptions?.headers)
        }
      };
      let response;
      if (options.method?.toUpperCase() === "GET") {
        const url = formatGetRequestUrl({
          endpoint: this.endpoint,
          query: queryAsString,
          variables
        });
        response = await this.fetch(url, options);
      } else {
        const body = this.createRequestBody(queryAsString, variables);
        response = await this.fetch(this.endpoint, {
          ...options,
          body,
          headers: typeof body === "string" ? { ...options.headers, "Content-Type": "application/json" } : options.headers
        });
      }
      if (!response.ok) {
        if (isResponseJSON(response)) {
          const { errors: errors2 } = await response.json();
          if (errors2?.[0]?.message !== void 0) {
            throw new GraphQLRequestError({
              query: queryAsString,
              variables,
              response,
              message: errors2[0].message,
              extensions: errors2[0].extensions
            });
          }
        }
        throw new GraphQLRequestError({
          query: queryAsString,
          variables,
          response,
          message: `Http Status ${response.status}`
        });
      }
      const { data, errors } = await response.json();
      if (errors?.[0] !== void 0) {
        throw new GraphQLRequestError({
          query: queryAsString,
          variables,
          response,
          message: errors[0].message,
          extensions: errors[0].extensions
        });
      }
      return { ok: true, data, response };
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      if (this.onError) {
        try {
          this.onError(error);
        } catch {
          return { ok: false, error };
        }
      }
      return { ok: false, error };
    }
  }
  /**
   * Makes GraphQL request and returns data or throws an error
   *
   * @example
   * const data = await request(...)
   *
   * @param query query
   * @param variables variables
   * @param fetchOptions overrides for fetch options
   */
  async request(query, variables, fetchOptions) {
    const result = await this.requestSafe(
      query,
      variables,
      fetchOptions
    );
    if (!result.ok) {
      throw result.error;
    }
    return result.data;
  }
};

// src/util/gql.ts
var gql = (strings, ...values) => {
  let result = "";
  for (const [index, string] of strings.entries()) {
    result += `${string}${index in values ? values[index] : ""}`;
  }
  return result.trim();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AwesomeGraphQLClient,
  GraphQLRequestError,
  gql,
  isFileUpload
});
