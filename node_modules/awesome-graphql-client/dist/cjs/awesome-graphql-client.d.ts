import { TypedDocumentNode } from '@graphql-typed-document-node/core';

interface Headers {
    get(name: string): string | null;
    forEach(callbackfn: (value: string, key: string) => void): void;
}
interface RequestResult {
    ok: boolean;
    headers: Headers;
    json: () => Promise<any>;
    status: number;
}
interface FetchOptions {
    method?: string;
    headers?: any;
    body?: any;
}

declare class GraphQLRequestError<TResponse extends RequestResult = Response> extends Error {
    query: string;
    variables?: Record<string, unknown>;
    response: TResponse;
    extensions?: Record<string, unknown>;
    constructor({ query, variables, response, message, extensions, }: {
        query: string;
        variables?: Record<string, unknown>;
        response: TResponse;
        message: string;
        extensions?: Record<string, unknown>;
    });
}

declare class AwesomeGraphQLClient<TQuery = string, TFetchOptions extends FetchOptions = RequestInit, TRequestResult extends RequestResult = Response> {
    private endpoint;
    private fetch;
    private fetchOptions?;
    private formatQuery?;
    private FormData;
    private onError?;
    private isFileUpload;
    constructor(config: {
        /** GraphQL endpoint */
        endpoint: string;
        /** Fetch polyfill if necessary */
        fetch?: (url: string, options?: any) => Promise<TRequestResult>;
        /** FormData polyfill if necessary */
        FormData?: any;
        /** Overrides for fetch options */
        fetchOptions?: TFetchOptions;
        /** Custom query formatter */
        formatQuery?: (query: TQuery) => string;
        /** Callback will be called on error  */
        onError?: (error: GraphQLRequestError | Error) => void;
        /** Custom predicate function for checking if value is a file */
        isFileUpload?: (value: unknown) => boolean;
    });
    private createRequestBody;
    /**
     * Sets a new GraphQL endpoint
     *
     * @param endpoint new overrides for endpoint
     */
    setEndpoint(endpoint: string): void;
    /**
     * Returns current GraphQL endpoint
     */
    getEndpoint(): string;
    /**
     * Sets new overrides for fetch options
     *
     * @param fetchOptions new overrides for fetch options
     */
    setFetchOptions(fetchOptions: TFetchOptions): void;
    /**
     * Returns current overrides for fetch options
     */
    getFetchOptions(): TFetchOptions | undefined;
    /**
     * Sends GraphQL Request and returns object with 'ok: true', 'data' and 'response' fields
     * or with 'ok: false' and 'error' fields.
     * Notice: this function never throws
     *
     * @example
     * const result = await requestSafe(...)
     * if (!result.ok) {
     *   throw result.error
     * }
     * console.log(result.data)
     *
     * @param query query
     * @param variables variables
     * @param fetchOptions overrides for fetch options
     */
    requestSafe<TData extends Record<string, any>, TVariables extends Record<string, any> = Record<string, never>>(query: TQuery extends TypedDocumentNode ? TypedDocumentNode<TData, TVariables> : TQuery, variables?: TVariables, fetchOptions?: TFetchOptions): Promise<{
        ok: true;
        data: TData;
        response: TRequestResult;
    } | {
        ok: false;
        error: GraphQLRequestError<TRequestResult> | Error;
    }>;
    /**
     * Makes GraphQL request and returns data or throws an error
     *
     * @example
     * const data = await request(...)
     *
     * @param query query
     * @param variables variables
     * @param fetchOptions overrides for fetch options
     */
    request<TData extends Record<string, any>, TVariables extends Record<string, any> = Record<string, never>>(query: TQuery extends TypedDocumentNode ? TypedDocumentNode<TData, TVariables> : TQuery, variables?: TVariables, fetchOptions?: TFetchOptions): Promise<TData>;
}

/**
 * Fake `graphql-tag`.
 * Recommended if you're using `graphql-tag` only for syntax highlighting
 * and static analysis such as linting and types generation.
 * It has less computational cost and makes overall smaller bundles. See:
 * https://github.com/lynxtaa/awesome-graphql-client#approach-2-use-fake-graphql-tag
 */
declare const gql: (strings: TemplateStringsArray, ...values: unknown[]) => string;

type StreamLike = {
    pipe: (...args: unknown[]) => unknown;
};
/** Uploadable file */
type FileUpload = File | Blob | Buffer | StreamLike | Promise<unknown>;
/**
 * Returns true if value is a file.
 * Supports File, Blob, Buffer and stream-like instances
 *
 * @param value incoming value
 */
declare const isFileUpload: (value: unknown) => value is FileUpload;

export { AwesomeGraphQLClient, FileUpload, GraphQLRequestError, gql, isFileUpload };
